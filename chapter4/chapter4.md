# 第四章 表达式

### 练习4.1

表达式5 + 10 * 20 / 2的求值结果是：105

### 练习4.2

```cpp
*(vec.begin())
(*(vec.begin())) + 1
```

### 练习4.3

C++语言并没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。
C++的思想是尽可能的相信程序员，将效率最大化。

### 练习4.4

```cpp
12 / 3 * 4 + 5 * 15 + 24 % 4 / 2
((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2) = 91
```

### 练习4.5

```cpp 
-30 * 3 + 21 / 5 = -86
-30 + 3 * 21 / 5 = -18
30 / 3 * 21 % 5 = 0
-30 / 3 * 21 % 4 = -2 // % 结果的正负号取决于被取余数
```

### 练习4.6

```cpp
if (i % 2 == 0)
if (i & 0x01)
```

### 练习4.7

溢出是当计算的结果超出该类型所能表示的范围的情况。

```cpp
short svalue = 32767; ++ svalue; // -32768
unsigned uivalue = 0; --uivalue; // 4294967295
unsigned short usvalue = 65535; ++usvalue; // 0 
```

### 练习4.8

逻辑与和逻辑或运算符都是先求左侧表达式结果，再求右侧表达式结果；当且仅当左侧表达式结果无法确定最终表达式的值时才会求右侧表达式的值。这种策略被称为短路求值。

相等性运算符并没有规定运算顺序。

### 练习4.9

```cpp
const char *cp = "hello world";
if (cp && *cp) // 首先判断cp是否为空指针，然后再判断cp的内容是否为0
```

### 练习4.10

```cpp
int i;
while (cin >> i && i != 42)
```

### 练习4.11

```cpp
a > b && b > c && c > d;
```

### 练习4.12********

```cpp
i != j < k;
(i != j) < k; // wrong
i != (j < k); // 
```

### 练习4.13

```cpp
int i;
double d;
d = i = 3.5; // i = 3, d = 3.0
i = d = 3.5; // d = 3.5, i = 3
```

### 练习4.14

```cpp
if (42 = i) // error
if (i = 42) // === 1
```

### 练习4.15

```cpp
double dval;
int ival;
int *pi;
dval = ival = pi = 0; // error
dval = ival = 0; // right
pi = 0; // right
```

### 练习4.16

```cpp
if (p = getPtr() != 0) // if ((p = getPtr()) != 0)
if (i = 1024) // if (i == 1024)
```

### 练习4.17

前置运算符是将对象本身作为左值返回，后置运算符返回原始对象的副本为右值；

### 练习4.18

将会从第二个元素开始取值，并且最后对v.end()也进行取值，结果是未定义的

### 练习4.19********

```cpp
ptr != 0 && *ptr++ // right
ival++ && ival // right
vec[ival++] <= vec[ival] // wrong C++未规定<=两侧的表达式的求值顺序
```

### 练习4.20



### 练习4.21



### 练习4.22



### 练习4.23



### 练习4.24



### 练习4.25



### 练习4.26



### 练习4.27



### 练习4.28



### 练习4.29



### 练习4.30



### 练习4.31



### 练习4.32



### 练习4.33



### 练习4.34



### 练习4.35



### 练习4.36



### 练习4.37



### 练习4.38





























